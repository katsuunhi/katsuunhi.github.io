
---
layout:     post
title:      "leetcode 刷题笔记"
date:       2021-06-17 15:32:00
author:     "Katsu"
---

leetcode 刷题笔记
## 1. O(n)时间，限制数组的数的范围，找消失的数
原地排序、异或运算

## 2. (i&1) == 0   i是偶数，注意&要加括号

## 3. 偶数^1 = 偶数+1， 奇数^1 = 奇数-1

## 4. 求和用accumulate(ans.begin(), ans.end(), 0);

## 5. string类型可以直接用+=在尾部追加字符串或者字符

## 6. stack的pop不返回元素，取顶部元素值为top()

## 7. 倒序思路：栈、递归

## 8. 取二进制的最后一个1：n = n&(-n);  删除最后一个1：n = n&(n-1);
lowbit(110100) = 000100
lowbit(n) = n&(-n)

## 9. 二分法用 low + (high - low) / 2, 防止high + low过大溢出

## 10. 使用摩尔投票一定要保证数量最多的元素只有一个
反例:[1,2,2,1,3]  摩尔投票结果为3

## 11. 下一个更大元素，用单调栈，单调栈存储的是下标，元素依次进栈，当下标对应的元素大于栈顶元素，说明该元素是栈顶元素的下一个更大元素，栈顶出栈并写入结果，一直判断到小于栈顶元素进栈。

## 12. 蔡勒公式：根据年月日计算得到星期几
改进版：基姆拉尔森计算公式   取消“世纪”，0为星期一，。。。6为星期日
```c++
    week=(day + 2*month + 3*(month + 1)/5 + year + year/4 - year/100 + year/400) % 7
```
$$ week = (day + 2*month + 3 *\frac{month+1}{5} + year + \frac{year}{4} - \frac{year}{100} + \frac{year}{400}) \\% 7 $$

## 二叉树基本结论：
    1. 第i层的节点数目 2^(i-1)
    2. 深度为k的二叉树至多有2^(k) - 1个结点（k>=1）,叶子节点为 2^(k - 1)
    3. 包含n个结点的二叉树的高度至少为( log2(n) )+1
    4. n0 = n2 + 1.



## 包含min函数的栈
需要用双栈结构来保存数据，因为会调用top函数，因此不能只用单栈保存当前的最小值。